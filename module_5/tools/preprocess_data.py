import json
import re
import os
import sys
from pathlib import Path

def extract_degree_from_program(program_name):
    """
    Extract degree information from program name
    Returns tuple of (cleaned_program_name, degree)
    """
    # Common degree patterns to look for
    degree_patterns = {
        r'PhD': 'PhD',
        r'Ph\.D\.': 'PhD',
        r'Doctorate': 'PhD',
        r'Doctoral': 'PhD',
        r'Master': 'Masters',
        r'MS ': 'Masters',
        r'MSc': 'Masters',
        r'M\.S\.': 'Masters',
        r'MA ': 'Masters',
        r'M\.A\.': 'Masters',
        r'MEng': 'Masters',
        r'M\.Eng\.': 'Masters',
        r'Bachelor': 'Bachelors',
        r'BS ': 'Bachelors',
        r'B\.S\.': 'Bachelors',
        r'BA ': 'Bachelors',
        r'B\.A\.': 'Bachelors'
    }
    
    # Default to empty if no match
    extracted_degree = ""
    
    # Try to match degree patterns
    for pattern, degree_value in degree_patterns.items():
        if re.search(pattern, program_name, re.IGNORECASE):
            extracted_degree = degree_value
            break
    
    # Clean program name (remove degree information)
    cleaned_program = program_name
    if extracted_degree:
        # Remove the degree words from program name
        for pattern in degree_patterns.keys():
            cleaned_program = re.sub(pattern, '', cleaned_program, flags=re.IGNORECASE)
        
        # Clean up any extra spaces
        cleaned_program = re.sub(r'\s+', ' ', cleaned_program).strip()
        
        # Remove trailing 's' if it's the last character (common artifact)
        if cleaned_program.endswith(' s'):
            cleaned_program = cleaned_program[:-2]
        
        # Additional cleaning for common artifacts
        cleaned_program = re.sub(r'\s+s\b', '', cleaned_program)  # Remove standalone 's'
        cleaned_program = re.sub(r'\s+program\b', '', cleaned_program, flags=re.IGNORECASE)  # Remove 'program'
        cleaned_program = re.sub(r'\s+degree\b', '', cleaned_program, flags=re.IGNORECASE)  # Remove 'degree'
    
    return cleaned_program, extracted_degree

def clean_program_name(program_name):
    """
    Additional cleaning for program names after degree extraction
    """
    # Remove trailing 's' if it's the last character (common artifact)
    if program_name.endswith(' s'):
        program_name = program_name[:-2]
    
    # Additional cleaning for common artifacts
    program_name = re.sub(r'\s+s\b', '', program_name)  # Remove standalone 's'
    program_name = re.sub(r'\s+program\b', '', program_name, flags=re.IGNORECASE)  # Remove 'program'
    program_name = re.sub(r'\s+degree\b', '', program_name, flags=re.IGNORECASE)  # Remove 'degree'
    
    return program_name.strip()

def preprocess_data(input_file, output_file):
    """
    Preprocess the data to extract degree information from program_name
    and create a new JSON file with only the required columns
    """
    print(f"Reading data from {input_file}...")
    
    try:
        # Try different encodings to read the file
        encodings_to_try = ['utf-8', 'utf-8-sig', 'latin1', 'cp1252']
        
        data = None
        successful_encoding = None
        
        for encoding in encodings_to_try:
            try:
                print(f"Trying to read with {encoding} encoding...")
                with open(input_file, 'r', encoding=encoding) as file:
                    data = json.load(file)
                successful_encoding = encoding
                print(f"Successfully read with {encoding} encoding")
                break
            except UnicodeDecodeError:
                print(f"Failed to read with {encoding} encoding")
                continue
            except json.JSONDecodeError as e:
                print(f"JSON parsing error with {encoding} encoding: {e}")
                continue
        
        if data is None:
            print("Could not read the file with any of the attempted encodings.")
            return False
        
        print(f"Processing {len(data)} records...")
        
        # Create a new list for processed records with only required columns
        processed_data = []
        
        # Process each record
        for i, record in enumerate(data):
            # Create a new record with only the required fields
            processed_record = {
                # p_id will be auto-generated by PostgreSQL
                "program": "",  # Will be populated below
                "comments": record.get("comments", ""),
                "date_added": record.get("date_added", ""),
                "url": record.get("url", ""),
                "status": record.get("status", ""),
                "term": record.get("season", ""),  # Rename season to term
                "us_or_international": record.get("student_type", ""),  # Rename student_type
                "gpa": record.get("gpa", ""),
                "gre": record.get("gre_score", ""),  # Rename gre_score
                "gre_v": record.get("gre_v_score", ""),  # Rename gre_v_score
                "gre_aw": record.get("gre_aw", ""),
                "degree": record.get("degree", "")
            }
            
            # Extract degree from program_name if degree is empty
            cleaned_program = ""
            if 'program_name' in record:
                cleaned_program, extracted_degree = extract_degree_from_program(record['program_name'])
                if not processed_record["degree"]:
                    processed_record["degree"] = extracted_degree
            
            # Create program field by combining university and cleaned program name
            if 'university' in record:
                if cleaned_program:
                    processed_record["program"] = f"{record['university']} - {cleaned_program}"
                else:
                    program_part = record.get('program_name', '')
                    # Apply additional cleaning to program_name
                    program_part = clean_program_name(program_part)
                    processed_record["program"] = f"{record['university']} - {program_part}"
            else:
                if cleaned_program:
                    processed_record["program"] = cleaned_program
                else:
                    program_part = record.get('program_name', '')
                    # Apply additional cleaning to program_name
                    program_part = clean_program_name(program_part)
                    processed_record["program"] = program_part
            
            # Final cleaning pass on the program field to remove any remaining artifacts
            processed_record["program"] = clean_program_name(processed_record["program"])
            
            processed_data.append(processed_record)
        
        # Save the processed data
        print(f"Saving processed data to {output_file}...")
        with open(output_file, 'w', encoding='utf-8') as file:
            json.dump(processed_data, file, indent=2, ensure_ascii=False)
        
        print(f"Successfully processed data and saved to {output_file}")
        print(f"Processed {len(processed_data)} records")
        
        # Print a sample record for verification
        if processed_data:
            print("\nSample processed record:")
            sample = processed_data[0]
            for key, value in sample.items():
                print(f"{key}: {value}")
        
    except Exception as e:
        print(f"Error: {e}")
        import traceback
        traceback.print_exc()
        return False
    
    return True

def main():
    # Get the directory of the current script
    script_dir = Path(__file__).parent.parent
    
    # Define default paths
    default_input = script_dir / "data" / "raw_data.json"
    default_output = script_dir / "data" / "processed_data.json"
    
    # Check for command line arguments
    if len(sys.argv) > 1:
        input_file = sys.argv[1]
    else:
        input_file = default_input
    
    if len(sys.argv) > 2:
        output_file = sys.argv[2]
    else:
        output_file = default_output
    
    # Create data directory if it doesn't exist
    os.makedirs(os.path.dirname(output_file), exist_ok=True)
    
    # Process the data
    success = preprocess_data(input_file, output_file)
    
    if success:
        print("\nData preprocessing completed successfully.")
    else:
        print("\nData preprocessing failed.")

if __name__ == "__main__":
    main()